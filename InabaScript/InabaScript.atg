
using System.Collections.Generic;

COMPILER InabaScript

/* Add auxiliary methods and declaration here. */

public static InabaScriptSource iss;

/* If you want your generated compiler case insensitive add the */
/* keyword IGNORECASE here. */

CHARACTERS
/* Add character set declarations here. */
capitalLetter = 'A'..'Z'.
smallLetter = 'a'..'z'.
letter = capitalLetter + smallLetter.
digit = "0123456789".
cr = '\r'.
lf = '\n'.
tab = '\t'.
underscore = '_'.
validInitialTypeChars = capitalLetter.
validInitialIdentChars = smallLetter.
validSubsequentIdentChars = underscore + letter + digit.
openBrace = '{'.
closeBrace = '}'.
openParens = '('.
closeParens = ')'.
openBracket = '['.
closeBracket = ']'.
validStringChars = letter + digit + "!£:$^&*()_+-=,./;[]©®<>?#:@~{}|".

TOKENS
/* Add token declarations here. */
ident = validInitialIdentChars {validSubsequentIdentChars}.
type = validInitialTypeChars {validSubsequentIdentChars}.
integer = digit {digit}.
float = digit {digit} '.' digit {digit}.
utf8bom = '\u00ef' '\u00bb' '\u00bf'.
validStringLiteral = '"' { validStringChars | ('\\' ('n'|'r'|'r'|'\\') ) } '"'.
colon = ':'.

PRAGMAS
/* Add pragma declarations here. */
/* Example: */
/*   switch = '$' { digit | letter }. (. Optional semantic action .) */


/* For a multi-line block comment: */
COMMENTS FROM "/*" TO "*/" NESTED
COMMENTS FROM "//" TO lf


/* Set the ignored characters (whitespaces) here, the blank character is */
/* ignored by default. */
/* Example, add line breaks to the ignore set. */
IGNORE cr + lf + tab


PRODUCTIONS

/* Add your productions here, one must have the same name as the grammar, */
/* it will be the start symbol (entry point of your compiler). */

Identifier<out string identifier> =
ident															(. identifier = t.val; .)
.

IntegerLiteral<out IExpression integer> =
integer															(. integer = new IntegerLiteral(long.Parse(t.val)); .)
.

Referencer<ref Scope scope, out IExpression expr> =				(. string identifier; .)
Identifier<out identifier>										(. expr = new Referencer(scope, identifier); .)
.

Expression<ref Scope scope, out IExpression expr> =				(. expr = null; .)
(
IntegerLiteral<out expr> |
Referencer<ref scope, out expr>
)
.

VariableDeclaration<ref Scope scope, out IStatement vardecl> =	(. string identifier; .)
																(. IExpression expr; .)
"var" 
Identifier<out identifier>
"=" 
Expression<ref scope, out expr>
																(. vardecl = new VariableDeclaration(identifier, expr); .)
																(. scope = new Scope(vardecl as VariableDeclaration, scope); .)
.



Statement<ref Scope scope, out IStatement statement> =
VariableDeclaration<ref scope, out statement>
.

/* InabaScript, like JavaScript is just a bunch of statements */
InabaScript =													(. Scope scope = null; .)
																(. IStatement stmt; .)
[utf8bom]
{
SYNC Statement<ref scope, out stmt> ";"							(. iss.statements.Add(stmt); .)
}
.

END InabaScript.
