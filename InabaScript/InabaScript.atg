
using System.Collections.Generic;
using ParameterList = System.Collections.Generic.List<InabaScript.IExpression>;

COMPILER InabaScript

/* Add auxiliary methods and declaration here. */

public static InabaScriptSource iss;
public static int anonnum = 0;

/* If you want your generated compiler case insensitive add the */
/* keyword IGNORECASE here. */

CHARACTERS
/* Add character set declarations here. */
capitalLetter = 'A'..'Z'.
smallLetter = 'a'..'z'.
letter = capitalLetter + smallLetter.
digit = "0123456789".
cr = '\r'.
lf = '\n'.
tab = '\t'.
underscore = '_'.
validInitialTypeChars = capitalLetter.
validInitialIdentChars = smallLetter.
validSubsequentIdentChars = underscore + letter + digit.
openBrace = '{'.
closeBrace = '}'.
openParens = '('.
closeParens = ')'.
openBracket = '['.
closeBracket = ']'.
negative = '-'.
space = " ".
validStringChars = letter + digit + "!£:$^&*()_+-=,./;[]©®<>?#:@~{}|" + space + tab.

TOKENS
/* Add token declarations here. */
ident = validInitialIdentChars {validSubsequentIdentChars}.
type = validInitialTypeChars {validSubsequentIdentChars}.
integer = [negative] digit {digit}.
float = digit {digit} '.' digit {digit}.
utf8bom = '\u00ef' '\u00bb' '\u00bf'.
validStringLiteral = '"' { validStringChars | ('\\' ('n'|'r'|'r'|'\\') ) } '"'.
colon = ':'.

PRAGMAS
/* Add pragma declarations here. */
/* Example: */
/*   switch = '$' { digit | letter }. (. Optional semantic action .) */


/* For a multi-line block comment: */
COMMENTS FROM "/*" TO "*/" NESTED
COMMENTS FROM "//" TO lf


/* Set the ignored characters (whitespaces) here, the blank character is */
/* ignored by default. */
/* Example, add line breaks to the ignore set. */
IGNORE cr + lf + tab


PRODUCTIONS

/* Add your productions here, one must have the same name as the grammar, */
/* it will be the start symbol (entry point of your compiler). */

Identifier<out string identifier> =
ident															(. identifier = t.val; .)
.

IntegerLiteral<out IExpression integer> =
integer															(. integer = new IntegerLiteral(long.Parse(t.val)); .)
.

StringLiteral<out IExpression str> = 
validStringLiteral												(. str = new StringLiteral(t.val.Substring(1, t.val.Length-2)); .)
.

Referencer<ref Scope scope, out IExpression expr> =				(. string identifier; .)
Identifier<out identifier>										(. expr = new Referencer(scope, identifier); .)
.

ParameterList<ref Scope scope, ParameterList list> =				(. IExpression expr; .)
PrimaryExpression<ref scope, out expr>								(. list.Add(expr); .)
{
	"," PrimaryExpression<ref scope, out expr>						(. list.Add(expr); .)
}
.

Invocation<ref Scope scope, IExpression lhs, out IExpression expr> =(. expr = null; .)
																	(. List<IExpression> list = new List<IExpression>(); .)
"("
	[ ParameterList<ref scope, list> ]
")"
[
	Invocation<ref scope, lhs, out expr>
]
																	(. expr = new FunctionCall(lhs, list); .)
.

FunctionCall<ref Scope scope, out IStatement stmt> =				(. IExpression expr = null; .)
(
	Referencer<ref scope, out expr> |
	FunctionDeclaration<ref scope, out expr>
)
Invocation<ref scope, expr, out expr>
																	(. stmt = new Invoker(expr); .)
.


Evaluatable<ref Scope scope, out IExpression expr> =				(. expr = null; .)
(
	Referencer<ref scope, out expr> |
	FunctionDeclaration<ref scope, out expr>
)
[
	Invocation<ref scope, expr, out expr>
]
.


FunctionDeclaration<ref Scope scope, out IExpression fundecl> =	(. string identifier; .)
																(. List<string> parameternames = new List<string>(); .)
																(. IStatement statement; .)
																(. IExpression retexpr = null; .)
"function"
"("
")"
																(. Function func = new Function("func" + anonnum++, parameternames); .)
																(. Scope childscope = new Scope(func, scope); .)
"{"
{
	Statement<ref childscope, out statement>					(. func.Add(statement); .)
}
[
	"return"
	PrimaryExpression<ref scope, out retexpr>					(. func.Return(retexpr); .)
	";"															(. func.Add(new ReturnStatement(retexpr)); .)
]
"}"																(. fundecl = func; .)
.


PrimaryExpression<ref Scope scope, out IExpression expr> =		(. expr = null; .)
(
	IntegerLiteral<out expr> |
	StringLiteral<out expr> |
	Evaluatable<ref scope, out expr>
)
.

VariableDeclaration<ref Scope scope, out IStatement vardecl> =	(. string identifier; .)
																(. IExpression expr; .)
"var" 
Identifier<out identifier>
"=" 
PrimaryExpression<ref scope, out expr>
																(. vardecl = new VariableDeclaration(identifier, expr); .)
																(. scope = new Scope(vardecl as VariableDeclaration, scope); .)
.



Statement<ref Scope scope, out IStatement statement> =			(. statement = null; .)

(
	(VariableDeclaration<ref scope, out statement> ";") |
	(FunctionCall<ref scope, out statement> ";")
)
.

/* InabaScript, like JavaScript is just a bunch of statements */
InabaScript =													(. Scope scope = iss.intrinsics; .)
																(. IStatement stmt; .)
[utf8bom]
{
	SYNC Statement<ref scope, out stmt>							(. iss.statements.Add(stmt); .)
}
.

END InabaScript.
