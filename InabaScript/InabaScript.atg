
using System.Collections.Generic;
using ParameterList = System.Collections.Generic.List<InabaScript.IExpression>;

COMPILER InabaScript

/* Add auxiliary methods and declaration here. */

public static InabaScriptSource iss;


/* If you want your generated compiler case insensitive add the */
/* keyword IGNORECASE here. */

CHARACTERS
/* Add character set declarations here. */
capitalLetter = 'A'..'Z'.
smallLetter = 'a'..'z'.
letter = capitalLetter + smallLetter.
digit = "0123456789".
cr = '\r'.
lf = '\n'.
tab = '\t'.
underscore = '_'.
validInitialTypeChars = capitalLetter.
validInitialIdentChars = smallLetter.
validSubsequentIdentChars = underscore + letter + digit.
openBrace = '{'.
closeBrace = '}'.
openParens = '('.
closeParens = ')'.
openBracket = '['.
closeBracket = ']'.
negative = '-'.
validStringChars = letter + digit + "!£:$^&*()_+-=,./;[]©®<>?#:@~{}|".

TOKENS
/* Add token declarations here. */
ident = validInitialIdentChars {validSubsequentIdentChars}.
type = validInitialTypeChars {validSubsequentIdentChars}.
integer = [negative] digit {digit}.
float = digit {digit} '.' digit {digit}.
utf8bom = '\u00ef' '\u00bb' '\u00bf'.
validStringLiteral = '"' { validStringChars | ('\\' ('n'|'r'|'r'|'\\') ) } '"'.
colon = ':'.

PRAGMAS
/* Add pragma declarations here. */
/* Example: */
/*   switch = '$' { digit | letter }. (. Optional semantic action .) */


/* For a multi-line block comment: */
COMMENTS FROM "/*" TO "*/" NESTED
COMMENTS FROM "//" TO lf


/* Set the ignored characters (whitespaces) here, the blank character is */
/* ignored by default. */
/* Example, add line breaks to the ignore set. */
IGNORE cr + lf + tab


PRODUCTIONS

/* Add your productions here, one must have the same name as the grammar, */
/* it will be the start symbol (entry point of your compiler). */

Identifier<out string identifier> =
ident															(. identifier = t.val; .)
.

IntegerLiteral<out IExpression integer> =
integer															(. integer = new IntegerLiteral(long.Parse(t.val)); .)
.

Referencer<ref Scope scope, out IExpression expr> =				(. string identifier; .)
Identifier<out identifier>										(. expr = new Referencer(scope, identifier); .)
.

ParameterList<ref Scope scope, ParameterList list> =				(. IExpression expr; .)
PrimaryExpression<ref scope, out expr>								(. list.Add(expr); .)
{
	"," PrimaryExpression<ref scope, out expr>						(. list.Add(expr); .)
}
.

Invocation<ref Scope scope, IExpression lhs, out IExpression expr> =(. expr = null; .)
																	(. List<IExpression> list = new List<IExpression>(); .)
"("
	[ ParameterList<ref scope, list> ]
")"
[
	Invocation<ref scope, lhs, out expr>
]
																	(. expr = new FunctionCall(lhs, list); .)
.

Evaluatable<ref Scope scope, out IExpression expr> =			(. expr = null; .)
Referencer<ref scope, out expr>
[
	Invocation<ref scope, expr, out expr>
]
.


PrimaryExpression<ref Scope scope, out IExpression expr> =		(. expr = null; .)
(
	IntegerLiteral<out expr> |
	Evaluatable<ref scope, out expr>
)
.

VariableDeclaration<ref Scope scope, out IStatement vardecl> =	(. string identifier; .)
																(. IExpression expr; .)
"var" 
Identifier<out identifier>
"=" 
PrimaryExpression<ref scope, out expr>
																(. vardecl = new VariableDeclaration(identifier, expr); .)
																(. scope = new Scope(vardecl as VariableDeclaration, scope); .)
.



Statement<ref Scope scope, out IStatement statement> =
VariableDeclaration<ref scope, out statement>
.

/* InabaScript, like JavaScript is just a bunch of statements */
InabaScript =													(. Scope scope = iss.intrinsics; .)
																(. IStatement stmt; .)
[utf8bom]
{
	SYNC Statement<ref scope, out stmt> ";"						(. iss.statements.Add(stmt); .)
}
.

END InabaScript.
