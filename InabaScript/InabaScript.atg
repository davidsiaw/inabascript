
using System.Collections.Generic;
using ParameterList = System.Collections.Generic.List<InabaScript.IExpression>;

COMPILER InabaScript

/* Add auxiliary methods and declaration here. */

public static InabaScriptSource iss;
public static int anonnum = 0;

/* If you want your generated compiler case insensitive add the */
/* keyword IGNORECASE here. */

CHARACTERS
/* Add character set declarations here. */
capitalLetter = 'A'..'Z'.
smallLetter = 'a'..'z'.
letter = capitalLetter + smallLetter.
digit = "0123456789".
cr = '\r'.
lf = '\n'.
tab = '\t'.
underscore = '_'.
validInitialTypeChars = capitalLetter.
validInitialIdentChars = smallLetter.
validSubsequentIdentChars = underscore + letter + digit.
openBrace = '{'.
closeBrace = '}'.
openParens = '('.
closeParens = ')'.
openBracket = '['.
closeBracket = ']'.
negative = '-'.
space = " ".
validStringChars = letter + digit + "!£:$^&*()_+-=,./;[]©®<>?#:@~{}|" + space + tab.

TOKENS
/* Add token declarations here. */
ident = validInitialIdentChars {validSubsequentIdentChars}.
type = validInitialTypeChars {validSubsequentIdentChars}.
integer = [negative] digit {digit}.
float = digit {digit} '.' digit {digit}.
utf8bom = '\u00ef' '\u00bb' '\u00bf'.
validStringLiteral = '"' { validStringChars | ('\\' ('n'|'r'|'r'|'\\') ) } '"'.
colon = ':'.

PRAGMAS
/* Add pragma declarations here. */
/* Example: */
/*   switch = '$' { digit | letter }. (. Optional semantic action .) */


/* For a multi-line block comment: */
COMMENTS FROM "/*" TO "*/" NESTED
COMMENTS FROM "//" TO lf


/* Set the ignored characters (whitespaces) here, the blank character is */
/* ignored by default. */
/* Example, add line breaks to the ignore set. */
IGNORE cr + lf + tab


PRODUCTIONS

/* Add your productions here, one must have the same name as the grammar, */
/* it will be the start symbol (entry point of your compiler). */

Identifier<out string identifier> =
ident															(. identifier = t.val; .)
.

IntegerLiteral<out IExpression integer> =
integer															(. integer = new IntegerLiteral(long.Parse(t.val)); .)
.

StringLiteral<out IExpression str> = 
validStringLiteral												(. str = new StringLiteral(t.val.Substring(1, t.val.Length-2)); .)
.

Referencer<ref Scope scope, out IExpression expr, Function func> =				(. string identifier; .)
Identifier<out identifier>										(. expr = new Referencer(scope, identifier, func); .)
.

ParameterList<ref Scope scope, ParameterList list, Function func> =				(. IExpression expr; .)
PrimaryExpression<ref scope, out expr, func>									(. list.Add(expr); .)
{
	"," PrimaryExpression<ref scope, out expr, func>							(. list.Add(expr); .)
}
.

Invocation<ref Scope scope, IExpression lhs, out IExpression expr, Function func> =(. expr = null; .)
																				(. List<IExpression> list = new List<IExpression>(); .)
"("
	[ ParameterList<ref scope, list, func> ]
")"
[
	Invocation<ref scope, lhs, out expr, func>
]
																				(. expr = new FunctionCall(lhs, list); .)
.

FunctionCall<ref Scope scope, out IStatement stmt, Function func> =				(. IExpression expr = null; .)
(
	Referencer<ref scope, out expr, func> |
	FunctionDeclaration<ref scope, out expr, func>
)
Invocation<ref scope, expr, out expr, func>
																				(. stmt = new Invoker(expr); .)
.


Evaluatable<ref Scope scope, out IExpression expr, Function func> =				(. expr = null; .)
(
	Referencer<ref scope, out expr, func> |
	FunctionDeclaration<ref scope, out expr, func>
)
[
	Invocation<ref scope, expr, out expr, func>
]
.


FunctionDeclaration<ref Scope scope, out IExpression fundecl, Function func> =
																				(. List<string> parameternames = new List<string>(); .)
																				(. IStatement statement; .)
																				(. IExpression retexpr = null; .)
"function"
"("
")"
																				(. Function innerfunc = new Function("func" + anonnum++, parameternames); .)
																				(. Scope childscope = new Scope(innerfunc, scope, innerfunc); .)
"{"
{
	Statement<ref childscope, out statement, innerfunc>							(. innerfunc.Add(statement); .)
}
[
	"return"
	PrimaryExpression<ref childscope, out retexpr, innerfunc>					(. innerfunc.Return(retexpr); .)
	";"																			(. innerfunc.Add(new ReturnStatement(retexpr)); .)
]
																				(. if (func != null) { func.AddExternalSymbol(innerfunc.OutsideSymbols); } .)
"}"																				(. fundecl = innerfunc; .)
.


PrimaryExpression<ref Scope scope, out IExpression expr, Function func> =		(. expr = null; .)
(
	IntegerLiteral<out expr> |
	StringLiteral<out expr> |
	Evaluatable<ref scope, out expr, func>
)
.

VariableDeclaration<ref Scope scope, out IStatement vardecl, Function func> =	(. string identifier; .)
																(. IExpression expr; .)
"var" 
Identifier<out identifier>
"=" 
PrimaryExpression<ref scope, out expr, func>
																(. vardecl = new VariableDeclaration(identifier, expr); .)
																(. scope = new Scope(vardecl as VariableDeclaration, scope); .)
.


Symbol<ref Scope scope, EnumType type, out VariableDeclaration vardecl> =(. string identifier; .)
Identifier<out identifier>										(. vardecl = new VariableDeclaration(identifier, new EnumLiteral(type, identifier)); .)
																(. scope = new Scope(vardecl as VariableDeclaration, scope); .)
.


EnumTypeDeclaration<ref Scope scope, out IStatement typedecl> =	(. string identifier; .)
																(. VariableDeclaration vardecl; .)
"type"
Identifier<out identifier>										(. EnumType type = new EnumType(identifier); .)
"="
Symbol<ref scope, type, out vardecl>							(. type.Add(vardecl); .)
{
	"|" Symbol<ref scope, type, out vardecl>					(. type.Add(vardecl); .)
}
																(. typedecl = type; .)
.



Statement<ref Scope scope, out IStatement statement, Function func> =(. statement = null; .)

(
	(VariableDeclaration<ref scope, out statement, func> ";") |
	(FunctionCall<ref scope, out statement, func> ";") |
	(EnumTypeDeclaration<ref scope, out statement> ";")
)
.

/* InabaScript, like JavaScript is just a bunch of statements */
InabaScript =													(. Scope scope = iss.intrinsics; .)
																(. IStatement stmt; .)
[utf8bom]
{
	SYNC Statement<ref scope, out stmt, null>					(. iss.statements.Add(stmt); .)
}
.

END InabaScript.
