using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using InabaScript;
using System.IO;

// Inabascript compiler

namespace isc {
    class Program {

        class CSource
        {
            public CSource(string source)
            {
                this.source = source;
                progname = Path.GetFileNameWithoutExtension(source);
                iss = new InabaScriptSource(source);
            }

            string progname;
            string source;
            InabaScriptSource iss;

            public void WriteOut(DirectoryInfo directory)
            {
                if (!directory.Exists)
                {
                    directory.Create();
                }

                string main = Path.Combine(directory.FullName, progname + ".c");

                WriteSourceFile(main);
                WriteMakeFile(directory);
            }

            private void WriteMakeFile(DirectoryInfo directory)
            {
                using (StreamWriter sw = new StreamWriter(Path.Combine(directory.FullName, "Makefile")))
                {
                    sw.WriteLine("# This file was generated by InabaScriptCompiler");
                    sw.WriteLine("# Program name: {0}", progname);
                    sw.WriteLine("# Generation time: {0} {1}", DateTime.Now.ToString(), TimeZone.CurrentTimeZone.StandardName);
                    sw.WriteLine("");

                    sw.WriteLine("CC = gcc");
                    sw.WriteLine("CFLAGS = -Wall -pedantic -g -std=c99");
                    sw.WriteLine("LDFLAGS = ");

                    sw.WriteLine("");
                    sw.WriteLine("# target: all - build {0}", progname);
                    sw.WriteLine("all: {0}", progname);
                    sw.WriteLine("\t# -----------------------------------");
                    sw.WriteLine("\t# {0}", progname);
                    sw.WriteLine("\t# Written in inabascript");
                    sw.WriteLine("\t# Transformation done with InabaScriptCompiler");

                    sw.WriteLine("");
                    sw.WriteLine("{0}: {0}.o", progname);
                    sw.WriteLine("\t# Linking {0}...", progname);
                    sw.WriteLine("\t$(CC) $(LDFLAGS) -o $@ $^");

                    sw.WriteLine("");
                    sw.WriteLine("{0}.o: {1}.c", progname, progname);
                    sw.WriteLine("\t# Making {0}...", progname);
                    sw.WriteLine("\t$(CC) $(CFLAGS) -c -o $@ $<");

                    sw.WriteLine("");
                    sw.WriteLine("# target: clean - Delete all files generated by make all");
                    sw.WriteLine("clean:");
                    sw.WriteLine("\trm -f {0} {0}.o", progname, progname);

                    sw.WriteLine("");
                    sw.WriteLine("# target: help - Display callable targets");
                    sw.WriteLine("help:");
                    sw.WriteLine("\tcat Makefile | egrep \"^# target:\"");


                    sw.WriteLine("");
                    sw.WriteLine(".PHONY: clean");

                }
            }



            List<string> functions = new List<string>();
            Dictionary<StaticFunctionType, KeyValuePair<string, string>> funcTypeDefs = new Dictionary<StaticFunctionType, KeyValuePair<string, string>>();
            Dictionary<CStruct, string> cstructToName = new Dictionary<CStruct, string>();

            private void WriteSourceFile(string main)
            {
                string mainfunc = "int main(int argc, char** argv)\n{";

                WriteStatementList("", ref mainfunc, iss.statements);

                mainfunc += "\n\treturn 0;\n}\n";

                using (StreamWriter sw = new StreamWriter(main))
                {
                    sw.WriteLine("// Created from " + progname + ".is");
                    sw.WriteLine("// by InabaScriptCompiler");
                    sw.WriteLine("// on " + DateTime.Now + " " + TimeZone.CurrentTimeZone.StandardName);
                    sw.WriteLine();

                    // includes
                    sw.WriteLine("#include <stdio.h>");
                    sw.WriteLine("#include <stdlib.h>");
                    sw.WriteLine();

                    // write func defs
                    sw.WriteLine("// Function definitions");
                    foreach (var v in funcTypeDefs.Values)
                    {
                        sw.WriteLine("typedef {0};", v.Value);
                        sw.WriteLine();

                        sw.WriteLine("typedef struct\n{");
                        sw.WriteLine("\t{0} func;", v.Key+"_func_t");
                        sw.WriteLine("\tvoid* context;");
                        sw.WriteLine("}} {0};\n", v.Key + "_func_t_bind_t");
                    }
                    sw.WriteLine();


                    // write struct declarations
                    sw.WriteLine("// Container types");
                    foreach (var kvpair in cstructToName)
                    {
                        sw.WriteLine("{0} {1};\n", kvpair.Key.Signature, kvpair.Value);
                    }

                    sw.WriteLine("");

                    functions.ForEach(x => sw.WriteLine(x));
                    sw.WriteLine(mainfunc);
                }
            }

            string GetStructName(CStruct strct)
            {
                if (!cstructToName.ContainsKey(strct))
                {
                    cstructToName[strct] = "struct_" + cstructToName.Count + "_t";
                }
                return cstructToName[strct];
            }

            class CStruct
            {
                IEnumerable<IDeclaration> decls;
                string signature;

                public CStruct(IEnumerable<IDeclaration> decls, CSource source)
                {
                    signature = "typedef struct {\n";

                    foreach (var decl in decls)
                    {
                        signature += "\t" + source.GetCType(decl.Type,false,true) + " " + decl.Name + ";\n";
                    }

                    signature += "}";
                    this.decls = decls;
                }

                public string Signature
                {
                    get
                    {
                        return signature;
                    }
                }

                public override bool Equals(object obj)
                {
                    if (obj is CStruct)
                    {
                        if ((obj as CStruct).signature == signature)
                        {
                            return true;
                        }
                    }
                    return false;
                }

                public override int GetHashCode()
                {
                    return signature.GetHashCode();
                }

            }

            private void WriteStatementList(string outerfuncname, ref string funcstr, List<IStatement> statements)
            {
                foreach (IStatement statement in statements)
                {
                    if (statement is VariableDeclaration)
                    {
                        VariableDeclaration vdecl = (statement as VariableDeclaration);

                        string type = GetCType(vdecl.Initializer.Type, true);
                        //if (vdecl.Initializer is Function)
                        //{
                        //    MakeFunction(vdecl.Name, outerfuncname, vdecl.Initializer as Function);
                        //}


                        string name = vdecl.Name;
                        string preps = "";

                        string initializer = TranslateExpression(vdecl.Initializer, outerfuncname, ref preps);
                        funcstr += preps + "\n\t" + type + " " + name + " = " + initializer + ";";

                    }
                    else if (statement is Invoker)
                    {
                        string preps = "";
                        funcstr += preps + "\n\t" + TranslateExpression((statement as Invoker).FuncCall, outerfuncname, ref preps) + ";";
                    }
                    else if (statement is ReturnStatement)
                    {
                        string preps = "";
                        ReturnStatement rs = statement as ReturnStatement;
                        string initializer = TranslateExpression(rs.Expression, outerfuncname, ref preps);

                        funcstr += preps + "\n\treturn " + initializer + ";";
                    }
                    else if (statement is EnumType)
                    {
                        EnumType et = statement as EnumType;
                        int count = 0;
                        foreach (var val in et.Values)
                        {
                            funcstr += "\n\tconst int " + val.Name + " = " + count++ + ";";
                        }

                    }
                    else
                    {
                        throw new Exception("unknown statement!");
                    }
                }
            }

            private void MakeFunction(string funcname, string outerfuncname, Function func)
            {
                StaticFunctionType sft = func.Type as StaticFunctionType;
                string returntype = GetCType(sft.ReturnType,true);


                string funcDef = returntype + " " + funcname + outerfuncname + "(" + "void* context" + ")\n";


                funcDef += "{";

                if (func.OutsideSymbols.Count() > 0)
                {
                    string structname = GetStructName(new CStruct(func.OutsideSymbols, this));
                    funcDef += "\n\t" + structname + "* _unpack = (" + structname + "*)context" + ";" ;

                    foreach (var decl in func.OutsideSymbols)
                    {
                        funcDef += "\n\t" + GetCType(decl.Type) + " " + decl.Name + " = _unpack->" + decl.Name + ";";
                    }
                }


                WriteStatementList("_in_" + GetFunctionName(funcname, outerfuncname), ref funcDef, func.Statements);
                funcDef += "\n}\n";
                functions.Add(funcDef);
            }

            private static string GetFunctionName(string funcname, string outerfuncname)
            {
                return funcname + outerfuncname;
            }

            private string GetCType(IType t, bool pointered = false, bool internalFunPtr = false)
            {
                string type = "";
                if (t is IntegerType)
                {
                    IntegerType it = t as IntegerType;
                    //if (it.Min > 0)
                    //{
                    //    if (it.Max <= byte.MaxValue)
                    //    {
                    //        type = "unsigned char";
                    //    }
                    //    else if (it.Max <= ushort.MaxValue)
                    //    {
                    //        type = "unsigned short";
                    //    }
                    //    else if (it.Max <= uint.MaxValue)
                    //    {
                    //        type = "unsigned int";
                    //    }
                    //    else
                    //    {
                            //type = "unsigned long long";
                            //suffix = "ULL";
                        //}
                    //}
                    //else
                    //{
                    //    if (it.Max <= sbyte.MaxValue && it.Min >= sbyte.MinValue)
                    //    {
                    //        type = "char";
                    //    }
                    //    else if (it.Max <= short.MaxValue && it.Min >= short.MinValue)
                    //    {
                    //        type = "short";
                    //    }
                    //    else if (it.Max <= int.MaxValue && it.Min >= int.MinValue)
                    //    {
                    //        type = "int";
                    //    }
                    //    else
                    //    {
                            type = "long long";
                    //    }
                    //}
                }
                else if (t is StringType)
                {
                    type = "const char*";
                }
                else if (t is NothingType)
                {
                    type = "void";
                }
                else if (t is StaticFunctionType)
                {
                    StaticFunctionType sft = t as StaticFunctionType;

                    if (!funcTypeDefs.ContainsKey(sft))
                    {
                        string rettype = GetCType(sft.ReturnType);
                        string alias = rettype.Replace(" ", "");
                        List<string> paramtypes = new List<string>();
                        foreach (IType pt in sft.ParameterTypes)
                        {
                            string paramtype = GetCType(pt, true);
                            paramtypes.Add(paramtype);
                            alias += "_p_" + paramtype;
                        }
                        string functype = alias + "_func_t";


                        if (sft.ReturnType is StaticFunctionType)
                        {
                            rettype += "*";
                        }

                        string typedef = rettype + " (*" + functype + ")" + "(" + string.Join(", ", paramtypes.Concat(new string[] { "void*" }).ToArray()) + ")";
                        funcTypeDefs[sft] = new KeyValuePair<string, string>(alias, typedef);
                    }

                    type = funcTypeDefs[sft].Key;

                    if (internalFunPtr)
                    {
                        type += "_func_t";
                    }
                    else
                    {
                        type += "_func_t_bind_t";
                    }

                    if (pointered)
                    {
                        type += "*";
                    }

                }
                else if (t is EnumType)
                {
                    type = "int";
                }
                else
                {
                    throw new Exception("Unknown type!");
                }
                return type;
            }



            private string TranslateExpression(IExpression expression, string outerfuncname, ref string preparations)
            {
                string initializer = "";

                if (expression is IntegerLiteral)
                {
                    initializer = (expression as IntegerLiteral).Value.ToString() + "LL";
                }
                else if (expression is StringLiteral)
                {
                    initializer = "\"" + (expression as StringLiteral).Value + "\"";
                }
                else if (expression is Referencer)
                {
                    initializer = (expression as Referencer).Name;
                }
                else if (expression is FunctionCall)
                {
                    string preps = "";
                    FunctionCall fc = expression as FunctionCall;

                    string callvarname = TranslateExpression(fc.LeftSideExpression, outerfuncname, ref preps);


                    initializer = callvarname + "->func" + "(" + string.Join(", ", fc.Parms.Select(x => TranslateExpression(x, outerfuncname, ref preps)).Concat(new string[] { callvarname + "->context" }).ToArray()) + ")";
                    preparations += preps;
                }
                else if (expression is Function)
                {
                    Function func = expression as Function;
                    MakeFunction(func.Name, outerfuncname, func);

                    string bindstructname = GetCType(func.Type,true);
                    string bindstructnameNoPtr = GetCType(func.Type);
                    string bindvarname = "_" + GetFunctionName(func.Name, outerfuncname) + "_bind";

                    preparations += "\n\n\t" + bindstructname + " " + bindvarname + " = malloc(sizeof(" + bindstructnameNoPtr + "));";
                    preparations += "\n\t" + bindvarname + "->func = " + GetFunctionName(func.Name, outerfuncname) + ";";

                    if (func.OutsideSymbols.Count() == 0)
                    {
                        preparations += "\n\t" + bindvarname + "->context = NULL;";
                    }
                    else
                    {
                        string contextPacker = bindvarname + "_context";
                        string contextPackerstructname = cstructToName[new CStruct(func.OutsideSymbols, this)];
                        preparations += "\n\t " + contextPackerstructname + "* " + contextPacker + " = malloc(sizeof(" + contextPackerstructname + "));";

                        foreach (var decl in func.OutsideSymbols)
                        {
                            preparations += "\n\t" + contextPacker + "->" + decl.Name + " = " + decl.Name + ";";
                        }

                        preparations += "\n\t" + bindvarname + "->context = " + contextPacker + ";";

                    }

                    initializer = "" + bindvarname;
                }
                else
                {
                    throw new Exception("Unknown expression!");
                }
                return initializer;
            }
        }

        static void Main(string[] args) {

            string source = @"..\..\..\testsources\simple.is";

            DirectoryInfo di = new DirectoryInfo(@"D:\starlight\");
            CSource cs = new CSource(source);
            cs.WriteOut(di);

        }

    }
}
